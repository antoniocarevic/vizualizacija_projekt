<!DOCTYPE html>
<html>
<head>
    <title>CSstats Visualizations</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background-color: #34495E;
            margin: 0; padding: 20px;
            color: #FFF;
            height: 100vh;
            overflow: hidden;
        }
        #site-title {
            text-align: center;
            font-size: clamp(1.2rem, 3vw, 1.8rem);
            font-weight: bold; color: #FFF;
            text-shadow: 2px 2px 4px #000;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }
        #site-title:hover { color: #FFD700; }
        
        .container {
            display: grid;
            grid-template-columns: 1.3fr 1fr;
            grid-template-rows: 1.3fr 1fr;
            gap: 15px;
            height: calc(100vh - 125px);
            max-width: 80vw;
            margin: 0 auto;
        }
        
        .viz-box {
            background: #FAFAFA;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 15px;
            color: black;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            max-width: 100%;
            align-items: center;
        }
        
        .heatmap-box {
            display: flex;
            flex-direction: row;
            align-items: stretch;
            padding: 10px;
        }
        
        .heatmap-left {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            width: 200px;
            padding-right: 15px;
            border-right: 1px solid #ddd;
        }
        
        .heatmap-right {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding-left: 15px;
        }
        
        .viz-box h3 {
            margin: 0 0 8px 0;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            color: #333;
            text-align: center;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center;
            justify-content: center;
        }
        
        .heatmap-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
            width: 100%;
        }
        
        .match-controls {
            width: 100%;
            max-width: 95vw;
            margin: 0 auto 15px auto;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        select, label {
            font-size: clamp(0.7rem, 1.5vw, 0.85rem);
            background: #003366;
            color: #FFF;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 6px 10px;
            cursor: pointer;
        }
        
        label {
            display: flex;
            align-items: center;
            white-space: nowrap;
        }
        
        input[type=checkbox] {
            margin-right: 4px;
        }
        
        .chart-container {
            flex: 1;
            position: relative;
            min-height: 0;
            padding: 5px;
            width: 85%;
            max-width: 90%;
            margin: 0 auto;
        }
        
        .heatmap-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        svg {
            width: 100%;
            height: 100%;
        }
        
        .tooltip {
            position: fixed;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 4px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            max-width: 200px;
        }
        
        .error-message {
            color: red;
            font-weight: bold;
            text-align: center;
            margin: 5px 0;
            font-size: 0.8rem;
        }
        
        .bar {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .bar:hover {
            filter: brightness(1.2);
        }
        
        .data-point {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .data-point:hover {
            r: 6;
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.5));
        }
        
        .axis {
            font-size: 10px;
        }
        
        .axis path,
        .axis line {
            fill: none;
            stroke: #333;
            stroke-width: 1;
        }
        
        .grid-line {
            stroke: #e0e0e0;
            stroke-width: 1;
            opacity: 0.7;
        }
        
        @media (max-width: 1024px) {
            body { padding: 15px; }
            .container { 
                grid-template-columns: 1fr;
                grid-template-rows: repeat(4, 1fr);
                height: calc(100vh - 100px);
                gap: 15px;
            }
            body { overflow-y: auto; }
            .chart-container {
                width: 95%;
                max-width: 100%;
            }
            .heatmap-box {
                flex-direction: column;
            }
            .heatmap-left {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #ddd;
                padding-right: 0;
                padding-bottom: 10px;
                margin-bottom: 10px;
            }
            .heatmap-right {
                padding-left: 0;
            }
        }
        
        @media (max-width: 768px) {
            body { padding: 10px; overflow-y: auto; }
            .viz-box { padding: 10px; }
            .controls { justify-content: flex-start; }
            select, label { font-size: 0.7rem; padding: 4px 8px; }
            #site-title { font-size: 1.4rem; margin-bottom: 10px; }
            .container { gap: 10px; }
            .chart-container {
                width: 100%;
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div id="site-title">CSstats</div>
    
    <div class="match-controls">
        <label for="match-selector">Match:</label>
        <select id="match-selector"></select>
    </div>
    
    <div class="error-message" id="error-message"></div>
    <div class="error-message" id="pie-error"></div>
    
    <div class="container">
        <div class="viz-box heatmap-box">
            <div class="heatmap-left">
                <h3>Kill Heatmap</h3>
                <div class="heatmap-controls">
                    <label for="heatmap-team-selector">Team:</label>
                    <select id="heatmap-team-selector">
                        <option value="all">All Teams</option>
                    </select>
                </div>
            </div>
            <div class="heatmap-right">
                <div class="heatmap-container" id="heatmap"></div>
            </div>
        </div>
        
        <div class="viz-box">
            <h3>Economy</h3>
            <div class="controls">
                <label for="team-selector">Team:</label>
                <select id="team-selector">
                    <option value="">Select team</option>
                    <option value="both">Both Teams</option>
                </select>
            </div>
            <div class="chart-container" id="linechart"></div>
        </div>
        
        <div class="viz-box">
            <h3>Round Wins</h3>
            <div class="chart-container" id="piechart"></div>
        </div>
        
        <div class="viz-box">
            <h3>Weapon Statistics</h3>
            <div class="controls">
                <label for="player-selector">Player:</label>
                <select id="player-selector">
                    <option value="all">All Players</option>
                </select>
                <label><input type="checkbox" id="bodyshots"> Bodyshots</label>
                <label><input type="checkbox" id="headshots"> Headshots</label>
            </div>
            <div class="chart-container" id="barchart"></div>
        </div>
    </div>
    
    <div id="tooltip" class="tooltip"></div>
    
    <script>
        let currentMatchData = null;
        let currentTeams = null;
        let currentMapConfig = null;
        
        const matchFiles = [
            "falcons-vs-gamerlegion-m1-ancient.json",
            "falcons-vs-gamerlegion-m2-nuke.json",
            "falcons-vs-gamerlegion-m3-inferno.json"
        ];
        
        const MAP_CONFIGS = {
            "ancient": { 
                pos_x: -2953,
                pos_y: 2164,
                scale: 5.2,
                image: "maps/de_ancient.png"
            },
            "nuke": { 
                pos_x: -3453,
                pos_y: 2887,
                scale: 7.0,
                image: "maps/de_nuke.webp"
            },
            "inferno": { 
                pos_x: -2087,
                pos_y: 3870,
                scale: 4.9,
                image: "maps/de_inferno.png"
            },
            "anubis": {
                pos_x: -2796,
                pos_y: 3328,
                scale: 5.22,
                image: "maps/de_anubis.webp"
            },
            "dust2": {
                pos_x: -2476,
                pos_y: 3239,
                scale: 4.4,
                image: "maps/de_dust2.webp"
            },
            "mirage": {
                pos_x: -3230,
                pos_y: 1713,
                scale: 5.0,
                image: "maps/de_mirage.webp"
            },
            "overpass": {
                pos_x: -4831,
                pos_y: 1781,
                scale: 5.2,
                image: "maps/de_overpass.webp"
            },
            "train": {
                pos_x: -2477,
                pos_y: 2392,
                scale: 4.7,
                image: "maps/de_train.webp"
            },
            "vertigo": {
                pos_x: -3168,
                pos_y: 1762,
                scale: 4.0,
                image: "maps/de_vertigo.webp"
            }
        };


        function csDemoManagerCoordTransform(gameX, gameY, mapConfig, radarSize = 1024) {
            const worldX = gameX - mapConfig.pos_x;
            const worldY = mapConfig.pos_y - gameY;
            
            const radarX = worldX / mapConfig.scale;
            const radarY = worldY / mapConfig.scale;
            
            const clampedX = Math.max(0, Math.min(radarSize, radarX));
            const clampedY = Math.max(0, Math.min(radarSize, radarY));
            
            return {
                x: clampedX,
                y: clampedY,
                worldX: worldX,
                worldY: worldY,
                isValid: radarX >= 0 && radarX <= radarSize && radarY >= 0 && radarY <= radarSize
            };
        }

        function scaleRadarToImage(radarCoords, imageWidth, imageHeight, radarSize = 1024) {
            const scaleX = imageWidth / radarSize;
            const scaleY = imageHeight / radarSize;
            
            return {
                x: radarCoords.x * scaleX,
                y: radarCoords.y * scaleY,
                isValid: radarCoords.isValid
            };
        }

        function gameToImageCoords(gameX, gameY, mapConfig, imageWidth, imageHeight) {
            const radarCoords = csDemoManagerCoordTransform(gameX, gameY, mapConfig);
            const imageCoords = scaleRadarToImage(radarCoords, imageWidth, imageHeight);
            
            return {
                x: Math.max(0, Math.min(imageWidth, imageCoords.x)),
                y: Math.max(0, Math.min(imageHeight, imageCoords.y)),
                isValid: imageCoords.isValid
            };
        }

        function getWeaponData(kills, player, filter) {
            const stats = {};
            kills.forEach(kill => {
                if (player !== "all" && kill.killerName !== player) return;
                const weapon = kill.weaponName;
                if (!weapon) return;
                if (!stats[weapon]) stats[weapon] = { weapon, count: 0, headshots: 0 };
                stats[weapon].count += 1;
                if (kill.isHeadshot === true) stats[weapon].headshots += 1;
            });
            let arr = Object.values(stats);
            if (filter === "body") arr = arr.map(s => ({ ...s, count: s.count - s.headshots, headshots: 0 }));
            if (filter === "head") arr = arr.map(s => ({ ...s, count: s.headshots, headshots: s.headshots }));
            return arr.filter(s => s.count > 0).sort((a, b) => b.count - a.count).slice(0, 5);
        }

        function getContainerDimensions(containerId) {
            const container = document.getElementById(containerId);
            const rect = container.getBoundingClientRect();
            return {
                width: Math.max(200, rect.width - 10),
                height: Math.max(120, rect.height - 10)
            };
        }

        function loadMatch(file) {
            ["heatmap", "linechart", "piechart", "barchart"].forEach(id => {
                d3.select(`#${id}`).selectAll("*").remove();
            });
            d3.select("#error-message").text("");
            d3.select("#pie-error").text("");

            const teamSelector = d3.select("#team-selector");
            teamSelector.selectAll("option").remove();
            teamSelector.append("option").attr("value", "").text("Select team");
            teamSelector.append("option").attr("value", "both").text("Both Teams");
            
            const heatmapTeamSelector = d3.select("#heatmap-team-selector");
            heatmapTeamSelector.selectAll("option").remove();
            heatmapTeamSelector.append("option").attr("value", "all").text("All Teams");
            
            const playerSelector = d3.select("#player-selector");
            playerSelector.selectAll("option").remove();
            playerSelector.append("option").attr("value", "all").text("All Players");
            
            document.getElementById("bodyshots").checked = false;
            document.getElementById("headshots").checked = false;

            fetch(file)
                .then(r => r.json())
                .then(data => {
                    currentMatchData = data;
                    const mapName = file.replace(/falcons-vs-gamerlegion-m\d+-|.json/g, '').replace(/de_/, '');
                    const mapConfig = MAP_CONFIGS[mapName];
                    currentMapConfig = mapConfig;
                    
                    if (!mapConfig) {
                        d3.select("#error-message").text(`Map config not found for ${mapName}.`);
                        return;
                    }

                    const teams = [
                        { name: data.teamA?.name || "Team A", color: "#003366" },
                        { name: data.teamB?.name || "Team B", color: "#FD7702" }
                    ];
                    currentTeams = teams;

                    teamSelector.append("option").attr("value", "teamA").text(teams[0].name);
                    teamSelector.append("option").attr("value", "teamB").text(teams[1].name);
                    
                    heatmapTeamSelector.append("option").attr("value", "teamA").text(teams[0].name);
                    heatmapTeamSelector.append("option").attr("value", "teamB").text(teams[1].name);

                    const players = new Set();
                    (data.kills || []).forEach(kill => {
                        if (kill.killerName) players.add(kill.killerName);
                    });
                    Array.from(players).sort().forEach(player => {
                        playerSelector.append("option").attr("value", player).text(player);
                    });

                    createHeatmap(data, mapConfig, teams);
                    createPieChart(data, teams);
                    createBarChart(data);
                    createLineChart(data, teams);

                    playerSelector.on("change", () => updateBarChart(currentMatchData));
                    document.getElementById("bodyshots").addEventListener("change", () => updateBarChart(currentMatchData));
                    document.getElementById("headshots").addEventListener("change", () => updateBarChart(currentMatchData));
                    teamSelector.on("change", function() {
                        updateLineChart(d3.select(this).property("value"), teams);
                    });
                    heatmapTeamSelector.on("change", function() {
                        updateHeatmap(currentMatchData, currentMapConfig, currentTeams, d3.select(this).property("value"));
                    });
                })
                .catch(error => {
                    d3.select("#error-message").text(`Error loading match data: ${error.message}`);
                });
        }

        function createHeatmap(data, mapConfig, teams) {
            updateHeatmap(data, mapConfig, teams, "all");
        }

        function updateHeatmap(data, mapConfig, teams, selectedTeam) {
            d3.select("#heatmap").selectAll("*").remove();
            
            const dims = getContainerDimensions('heatmap');
            const size = Math.min(dims.width, dims.height) * 1.2;
            
            const svg = d3.select("#heatmap").append("svg")
                .attr("viewBox", `0 0 ${size} ${size}`)
                .attr("preserveAspectRatio", "xMidYMid meet")
                .style("max-width", "100%")
                .style("max-height", "100%");

            svg.append("image")
                .attr("xlink:href", mapConfig.image)
                .attr("width", size)
                .attr("height", size)
                .attr("opacity", 0)
                .transition().duration(1000).attr("opacity", 0.9);

            const kills = data.kills || [];
            
            let filteredKills = kills;
            if (selectedTeam === "teamA") {
                filteredKills = kills.filter(kill => kill.killerTeamName === teams[0].name);
            } else if (selectedTeam === "teamB") {
                filteredKills = kills.filter(kill => kill.killerTeamName === teams[1].name);
            }
            
            const imageKills = filteredKills.map(kill => {
                const coords = gameToImageCoords(kill.victimX, kill.victimY, mapConfig, size, size);
                return {
                    x: coords.x,
                    y: coords.y,
                    isValid: coords.isValid
                };
            }).filter(kill => kill.isValid);
            
            if (imageKills.length === 0) {
                svg.append("text")
                    .attr("x", size / 2)
                    .attr("y", size / 2)
                    .attr("text-anchor", "middle")
                    .attr("fill", "red")
                    .style("font-size", "16px")
                    .text("No kill data available for selected team");
                return;
            }
            
            const cellSize = Math.max(8, Math.min(25, size / Math.sqrt(imageKills.length) || 15));
            const numCols = Math.floor(size / cellSize);
            const numRows = Math.floor(size / cellSize);
            const grid = Array(numRows).fill(0).map(() => Array(numCols).fill(0));

            imageKills.forEach(kill => {
                const col = Math.floor(kill.x / cellSize);
                const row = Math.floor(kill.y / cellSize);
                if (row >= 0 && row < numRows && col >= 0 && col < numCols) {
                    grid[row][col]++;
                }
            });

            let maxCount = 0;
            const heatmapCells = [];
            for (let r = 0; r < numRows; r++) {
                for (let c = 0; c < numCols; c++) {
                    const count = grid[r][c];
                    if (count > maxCount) maxCount = count;
                    if (count > 0) {
                        heatmapCells.push({
                            x: c * cellSize,
                            y: r * cellSize,
                            width: cellSize,
                            height: cellSize,
                            count
                        });
                    }
                }
            }

            let colorScale;
            if (selectedTeam === "teamA") {
                colorScale = d3.scale.linear()
                    .domain([0, maxCount])
                    .range(["rgba(255, 255, 255, 0.7)", "rgba(0, 17, 102, 1)"]);
            } else if (selectedTeam === "teamB") {
                colorScale = d3.scale.linear()
                    .domain([0, maxCount])
                    .range(["rgba(255, 255, 255, 0.7)", "rgba(253, 119, 2, 1)"]);
            } else {
                colorScale = d3.scale.linear()
                    .domain([0, maxCount])
                    .range(["rgba(255, 255, 255, 0.7)", "rgba(255, 0, 0, 0.9)"]);
            }

            svg.selectAll(".heatmap-cell")
                .data(heatmapCells)
                .enter().append("rect")
                .attr("class", "heatmap-cell")
                .attr("x", d => d.x)
                .attr("y", d => d.y)
                .attr("width", d => d.width)
                .attr("height", d => d.height)
                .attr("fill", d => colorScale(d.count))
                .attr("opacity", 0)
                .on("mouseover", function(d) {
                    d3.select("#tooltip")
                        .style("left", (d3.event.pageX + 10) + "px")
                        .style("top", (d3.event.pageY - 10) + "px")
                        .html(`<strong>Kills in this area: ${d.count}</strong><br>Team: ${selectedTeam === "all" ? "All Teams" : (selectedTeam === "teamA" ? teams[0].name : teams[1].name)}`)
                        .style("display", "block");
                })
                .on("mouseout", function() {
                    d3.select("#tooltip").style("display", "none");
                })
                .transition().duration(500).attr("opacity", 0.8);
        }

        function createPieChart(data, teams) {
            const dims = getContainerDimensions('piechart');
            const size = Math.min(dims.width, dims.height);
            const radius = size / 3;

            const svg = d3.select("#piechart").append("svg")
                .attr("viewBox", `0 0 ${dims.width} ${dims.height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");

            const g = svg.append("g")
                .attr("transform", `translate(${dims.width/2},${dims.height/2})`);

            const rounds = data.rounds || [];
            const wins = rounds.reduce((acc, round) => {
                const winner = round.winnerTeamName ? round.winnerTeamName.trim() : null;
                if (!winner) return acc;
                if (winner === teams[0].name) acc.teamA++;
                else if (winner === teams[1].name) acc.teamB++;
                return acc;
            }, { teamA: 0, teamB: 0 });

            const pieData = [
                { label: teams[0].name, value: wins.teamA },
                { label: teams[1].name, value: wins.teamB }
            ];

            const pie = d3.layout.pie().value(d => d.value).sort(null);
            const arc = d3.svg.arc().innerRadius(0).outerRadius(radius);

            const arcs = g.selectAll(".arc")
                .data(pie(pieData))
                .enter().append("g")
                .attr("class", "arc");

            arcs.append("path")
                .attr("fill", (d, i) => teams[i].color)
                .attr("d", arc)
                .each(function(d) { this._current = { startAngle: d.startAngle, endAngle: d.startAngle }; })
                .transition().duration(1000)
                .attrTween("d", function(d) {
                    const interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return t => arc(interpolate(t));
                });

            arcs.append("text")
                .attr("transform", d => `translate(${arc.centroid(d)})`)
                .attr("dy", ".35em")
                .style("text-anchor", "middle")
                .style("fill", "white")
                .style("font-weight", "bold")
                .style("font-size", "16px")
                .text(d => d.data.value > 0 ? d.data.value : "")
                .attr("opacity", 0)
                .transition().duration(500).attr("opacity", 1);

            const legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(75, 10)`);

            pieData.forEach((data, i) => {
                const legendRow = legend.append("g")
                    .attr("transform", `translate(0, ${i * 17})`);
                legendRow.append("rect")
                    .attr("x", 0).attr("y", 0)
                    .attr("width", 12).attr("height", 12)
                    .attr("fill", teams[i].color);
                legendRow.append("text")
                    .attr("x", 14).attr("y", 11)
                    .style("font-size", "12px")
                    .text(data.label);
            });
        }

        function createBarChart(data) {
            updateBarChart(data);
        }

        function updateBarChart(matchData) {
            d3.select("#barchart").selectAll("svg").remove();
            
            const dims = getContainerDimensions('barchart');
            const margin = { top: 15, right: 15, bottom: 40, left: 40 };
            const width = dims.width - margin.left - margin.right;
            const height = dims.height - margin.top - margin.bottom;

            const svg = d3.select("#barchart").append("svg")
                .attr("viewBox", `0 0 ${dims.width} ${dims.height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const selectedPlayer = d3.select("#player-selector").property("value");
            const bodyshotsChecked = document.getElementById("bodyshots").checked;
            const headshotsChecked = document.getElementById("headshots").checked;
            
            let filter = "";
            if (bodyshotsChecked && !headshotsChecked) filter = "body";
            else if (headshotsChecked && !bodyshotsChecked) filter = "head";
            
            const weaponData = getWeaponData(matchData.kills, selectedPlayer, filter);

            if (weaponData.length === 0) {
                g.append("text")
                    .attr("x", width / 2)
                    .attr("y", height / 2)
                    .attr("text-anchor", "middle")
                    .attr("fill", "red")
                    .style("font-size", "10px")
                    .text("No weapon kill data available.");
                return;
            }

            const maxKills = d3.max(weaponData, d => d.count) || 1;
            const xScale = d3.scale.ordinal()
                .domain(weaponData.map(d => d.weapon))
                .rangeRoundBands([0, width], 0.2);
            const yScale = d3.scale.linear()
                .domain([0, maxKills])
                .range([height, 0]);

            const yTicks = yScale.ticks(4);
            g.selectAll(".grid-line")
                .data(yTicks)
                .enter().append("line")
                .attr("class", "grid-line")
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", d => yScale(d))
                .attr("y2", d => yScale(d))
                .style("stroke", "#e0e0e0")
                .style("stroke-width", 1)
                .style("opacity", 0.7);

            const xAxis = d3.svg.axis().scale(xScale).orient("bottom");
            const yAxis = d3.svg.axis().scale(yScale).orient("left").ticks(4);

            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(xAxis)
                .selectAll("text")
                .style("text-anchor", "end")
                .style("font-size", "11px")
                .style("font-weight", "400")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-45)");

            g.append("g")
                .attr("class", "axis")
                .call(yAxis)
                .selectAll("text")
                .style("font-size", "12px")
                .style("font-weight", "500");

            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -45)
                .attr("x", -height / 2)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-size", "16px")
                .style("font-weight", "500")
                .style("fill", "#333")
                .text("Kills");

            const bars = g.selectAll(".bar")
                .data(weaponData)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", d => xScale(d.weapon))
                .attr("width", xScale.rangeBand())
                .attr("y", height)
                .attr("height", 0)
                .attr("fill", "#003366")
                .attr("stroke", "#001f4d")
                .attr("stroke-width", 1)
                .attr("rx", 2)
                .attr("ry", 2)
                .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.2))")
                .style("cursor", "pointer")
                .on("mouseover", function(d) {
                    d3.select(this)
                        .transition().duration(200)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3)) brightness(1.1)");
                    
                    const rect = this.getBoundingClientRect();
                    d3.select("#tooltip")
                        .style("left", (rect.left + rect.width / 2) + "px")
                        .style("top", (rect.top - 10) + "px")
                        .html(`<strong>${d.weapon}</strong><br>Kills: ${d.count}<br>Headshots: ${d.headshots}<br>Accuracy: ${((d.headshots/d.count)*100).toFixed(1)}%`)
                        .style("display", "block");
                })
                .on("mouseout", function() {
                    d3.select(this)
                        .transition().duration(200)
                        .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.2))");
                    d3.select("#tooltip").style("display", "none");
                });

            bars.transition().duration(1000)
                .ease("bounce")
                .attr("y", d => yScale(d.count))
                .attr("height", d => height - yScale(d.count));

            g.selectAll(".bar-label")
                .data(weaponData)
                .enter().append("text")
                .attr("class", "bar-label")
                .attr("x", d => xScale(d.weapon) + xScale.rangeBand() / 2)
                .attr("y", height)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("font-weight", "400")
                .style("fill", "#333")
                .text(d => d.count)
                .transition().duration(1000)
                .delay(600)
                .attr("y", d => yScale(d.count) - 3);
        }

        function createLineChart(data, teams) {
            const dims = getContainerDimensions('linechart');
            const margin = { top: 20, right: 20, bottom: 40, left: 40 };
            const width = dims.width - margin.left - margin.right;
            const height = dims.height - margin.top - margin.bottom;

            const svg = d3.select("#linechart").append("svg")
                .attr("viewBox", `0 0 ${dims.width} ${dims.height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const rounds = data.rounds || [];
            const lineData = rounds.map((round, index) => ({
                x: index + 1,
                teamA: round.teamAStartMoney || 0,
                teamB: round.teamBStartMoney || 0,
                winner: round.winnerTeamName || "No winner"
            }));

            const xScale = d3.scale.linear()
                .domain([1, lineData.length])
                .range([0, width]);
            const maxMoney = d3.max(lineData, d => Math.max(d.teamA, d.teamB)) / 1000 || 50;
            const yScale = d3.scale.linear()
                .domain([0, Math.ceil(maxMoney / 10) * 10])
                .range([height, 0]);

            const yTicks = yScale.ticks(4);
            g.selectAll(".grid-line-y")
                .data(yTicks)
                .enter().append("line")
                .attr("class", "grid-line")
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", d => yScale(d))
                .attr("y2", d => yScale(d))
                .style("stroke", "#e0e0e0")
                .style("stroke-width", 1)
                .style("opacity", 0.5);

            const xAxis = d3.svg.axis().scale(xScale).orient("bottom").ticks(Math.min(8, lineData.length));
            const yAxis = d3.svg.axis().scale(yScale).orient("left").ticks(4)
                .tickFormat(d => d === 0 ? "0" : `${d}k`);

            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(xAxis)
                .selectAll("text")
                .style("font-size", "12px")
                .style("font-weight", "500");

            g.append("g")
                .attr("class", "axis")
                .call(yAxis)
                .selectAll("text")
                .style("font-size", "12px")
                .style("font-weight", "500");

            const lineA = d3.svg.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.teamA / 1000))
                .interpolate("linear");
            
            const lineB = d3.svg.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.teamB / 1000))
                .interpolate("linear");

            const pathA = g.append("path")
                .datum(lineData)
                .attr("class", "line-teamA")
                .attr("fill", "none")
                .attr("stroke", teams[0].color)
                .attr("stroke-width", 2)
                .attr("stroke-linecap", "round")
                .attr("stroke-linejoin", "round")
                .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.2))")
                .attr("d", lineA)
                .style("display", "none");

            const pathB = g.append("path")
                .datum(lineData)
                .attr("class", "line-teamB")
                .attr("fill", "none")
                .attr("stroke", teams[1].color)
                .attr("stroke-width", 2)
                .attr("stroke-linecap", "round")
                .attr("stroke-linejoin", "round")
                .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.2))")
                .attr("d", lineB)
                .style("display", "none");

            g.selectAll(".data-point-teamA")
                .data(lineData)
                .enter().append("circle")
                .attr("class", "data-point data-point-teamA")
                .attr("cx", d => xScale(d.x))
                .attr("cy", d => yScale(d.teamA / 1000))
                .attr("r", 3)
                .attr("fill", teams[0].color)
                .attr("stroke", "white")
                .attr("stroke-width", 1)
                .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.3))")
                .style("cursor", "pointer")
                .style("display", "none")
                .attr("opacity", 0);

            g.selectAll(".data-point-teamB")
                .data(lineData)
                .enter().append("circle")
                .attr("class", "data-point data-point-teamB")
                .attr("cx", d => xScale(d.x))
                .attr("cy", d => yScale(d.teamB / 1000))
                .attr("r", 3)
                .attr("fill", teams[1].color)
                .attr("stroke", "white")
                .attr("stroke-width", 1)
                .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.3))")
                .style("cursor", "pointer")
                .style("display", "none")
                .attr("opacity", 0);

            g.selectAll(".data-point-teamA")
                .on("mouseover", function(d) {
                    d3.select(this)
                        .transition().duration(200)
                        .attr("r", 5);
                    
                    const rect = this.getBoundingClientRect();
                    const didWin = (d.winner === teams[0].name) ? "✓ Yes" : "✗ No";
                    d3.select("#tooltip")
                        .style("left", (rect.left + rect.width / 2) + "px")
                        .style("top", (rect.top - 10) + "px")
                        .html(`<strong>Round ${d.x}</strong><br><span style="color:${teams[0].color}">● ${teams[0].name}</span><br>Money: $${d.teamA.toLocaleString()}<br>Won: ${didWin}`)
                        .style("display", "block");
                })
                .on("mouseout", function() {
                    d3.select(this)
                        .transition().duration(200)
                        .attr("r", 3);
                    d3.select("#tooltip").style("display", "none");
                });

            g.selectAll(".data-point-teamB")
                .on("mouseover", function(d) {
                    d3.select(this)
                        .transition().duration(200)
                        .attr("r", 5);
                    
                    const rect = this.getBoundingClientRect();
                    const didWin = (d.winner === teams[1].name) ? "✓ Yes" : "✗ No";
                    d3.select("#tooltip")
                        .style("left", (rect.left + rect.width / 2) + "px")
                        .style("top", (rect.top - 10) + "px")
                        .html(`<strong>Round ${d.x}</strong><br><span style="color:${teams[1].color}">● ${teams[1].name}</span><br>Money: $${d.teamB.toLocaleString()}<br>Won: ${didWin}`)
                        .style("display", "block");
                })
                .on("mouseout", function() {
                    d3.select(this)
                        .transition().duration(200)
                        .attr("r", 3);
                    d3.select("#tooltip").style("display", "none");
                });

            g.append("text")
                .attr("transform", `translate(${width/2},${height + 36})`)
                .style("text-anchor", "middle")
                .style("font-size", "16px")
                .style("font-weight", "500")
                .style("fill", "#333")
                .text("Round");

            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -45)
                .attr("x", -height / 2)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .style("font-weight", "500")
                .style("fill", "#333")
                .text("Money ($)");

            const legend = g.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(${width - 80}, 10)`);

            teams.forEach((team, i) => {
                const legendRow = legend.append("g")
                    .attr("transform", `translate(0, ${i * 14})`);
                
                legendRow.append("circle")
                    .attr("cx", 8).attr("cy", 8)
                    .attr("r", 5)
                    .attr("fill", team.color)
                    .attr("stroke", "white")
                    .attr("stroke-width", 1);
                
                legendRow.append("text")
                    .attr("x", 14).attr("y", 12)
                    .style("font-size", "12px")
                    .style("font-weight", "500")
                    .style("fill", "#333")
                    .text(team.name);
            });

            g.append("text")
                .attr("class", "prompt-message")
                .attr("x", width / 2)
                .attr("y", height / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "#666")
                .style("font-size", "11px")
                .style("font-weight", "500")
                .text("Select a team from the dropdown to view the line chart");
        }

        function animateLineAndPoints(team, show) {
            const path = d3.select(`.line-${team}`);
            const points = d3.selectAll(`.data-point-${team}`);
            
            if (show) {
                path.style("display", "block");
                const totalLength = path.node().getTotalLength();
                path.attr("stroke-dasharray", totalLength + " " + totalLength)
                    .attr("stroke-dashoffset", totalLength)
                    .transition()
                    .duration(1200)
                    .ease("cubic-out")
                    .attr("stroke-dashoffset", 0);
                
                points.style("display", "block")
                    .transition().delay(800).duration(400)
                    .ease("back-out")
                    .attr("opacity", 0.9);
            } else {
                path.transition().duration(300)
                    .ease("cubic-in")
                    .attr("stroke-dashoffset", path.node().getTotalLength())
                    .each("end", function() { 
                        d3.select(this).style("display", "none"); 
                    });
                points.transition().duration(200)
                    .ease("cubic-in")
                    .attr("opacity", 0)
                    .each("end", function() { 
                        d3.select(this).style("display", "none"); 
                    });
            }
        }

        function updateLineChart(selectedTeam, teams) {
            d3.select("#linechart").selectAll(".prompt-message").style("display", "none");
            
            if (selectedTeam === "both") {
                animateLineAndPoints("teamA", true);
                animateLineAndPoints("teamB", true);
            } else if (selectedTeam === "teamA") {
                animateLineAndPoints("teamA", true);
                animateLineAndPoints("teamB", false);
            } else if (selectedTeam === "teamB") {
                animateLineAndPoints("teamA", false);
                animateLineAndPoints("teamB", true);
            }
        }

        const matchSelector = d3.select("#match-selector");
        Promise.all(matchFiles.map(file => fetch(file).then(res => res.json())))
            .then(datas => {
                const options = matchFiles.map((file, i) => {
                    const data = datas[i];
                    const mapName = file.replace(/falcons-vs-gamerlegion-m\d+-|.json/g, '').replace(/_/g, ' ');
                    const formattedMapName = mapName.charAt(0).toUpperCase() + mapName.slice(1);
                    return {
                        file,
                        label: `${data.teamA?.name || "Team A"} vs ${data.teamB?.name || "Team B"} - ${formattedMapName}`
                    };
                });
                
                matchSelector.selectAll("option")
                    .data(options).enter()
                    .append("option")
                    .attr("value", d => d.file)
                    .text(d => d.label);
                
                if (matchFiles.length > 0) loadMatch(matchFiles[0]);
                
                matchSelector.on("change", function() {
                    const selectedFile = d3.select(this).property("value");
                    loadMatch(selectedFile);
                });
            })
            .catch(error => {
                matchSelector.append("option").text("Error loading matches");
            });

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (currentMatchData) {
                    const selectedFile = d3.select("#match-selector").property("value");
                    if (selectedFile) loadMatch(selectedFile);
                }
            }, 250);
        });
    </script>
</body>
</html>
