<!DOCTYPE html>
<html>
<head>
    <title>CSstats Visualizations</title>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #34495E;
        }
        #site-title {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 2.5em;
            font-weight: bold;
            color: #FFFFFF;
            text-shadow: 2px 2px 4px #000000;
            letter-spacing: 2px;
            transition: color 0.3s ease;
        }
        #site-title:hover {
            color: #FFD700;
        }
        #heatmap, #linechart, #piechart, #barchart {
            background-color: #FAFAFA;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            position: absolute;
            overflow: hidden;
        }
        #heatmap {
            top: 20px;
            left: 350px;
            width: 500px;
            height: 500px;
        }
        #linechart {
            top: 20px;
            right: 200px;
            width: 600px;
            height: 400px;
        }
        #piechart {
            top: 560px;
            left: 350px;
            width: 500px;
            height: 300px;
        }
        #barchart {
            top: 460px;
            right: 200px;
            width: 600px;
            height: 400px;
        }
        #error-message, #pie-error {
            color: red;
            font-weight: bold;
            position: absolute;
        }
        #error-message {
            top: 540px;
            left: 200px;
        }
        #pie-error {
            top: 880px;
            left: 200px;
        }
        .heatmap-cell {
            fill-opacity: 0.7;
        }
        line {
            shape-rendering: crispEdges;
        }
        .axis path,
        .axis line {
            fill: none;
            stroke: black;
            stroke-width: 1;
            shape-rendering: crispEdges;
        }
        .axis text {
            fill: black;
            font-size: 10px;
        }
        .legend text {
            font-size: 12px;
            fill: black;
        }
        .bar {
            fill: #003366;
        }
        #match-selector {
            position: relative;
            top: 145px;
            left: 10px;
            padding: 5px;
            font-size: 14px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        #filter-controls {
            position: absolute;
            top: 870px;
            right: 250px;
        }
        #filter-controls label {
            margin-right: 15px;
            color: #FFFFFF;
            font-size: 14px;
        }
        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 6px 10px;
            font-size: 15px;
            border-radius: 4px;
            pointer-events: none;
            display: none;
            transform: translateX(-50%);
            z-index: 1000;
        }
        .data-point {
            fill: white;
            stroke: black;
            stroke-width: 1;
            opacity: 0.7;
            pointer-events: all;
        }
    </style>
</head>
<body>
    <div id="site-title">CSstats</div>
    <div id="error-message"></div>
    <div id="pie-error"></div>
    <div id="heatmap"></div>
    <div id="linechart"></div>
    <div id="piechart"></div>
    <div id="barchart"></div>
    <select id="match-selector"></select>
    <div id="tooltip" class="tooltip"></div>
    <div id="filter-controls">
        <label><input type="checkbox" id="bodyshots"> Bodyshots</label>
        <label><input type="checkbox" id="headshots"> Headshots</label>
    </div>

    <script>
        const matchFiles = [
            "falcons-vs-gamerlegion-m1-ancient.json",
            "falcons-vs-gamerlegion-m2-nuke.json",
            "falcons-vs-gamerlegion-m3-inferno.json"
        ];

        const MAP_CONFIGS = {
            "ancient": {
                image: "de_ancient.png",
                pos_x: -2048,
                pos_y: 3072,
                scale: 4
            },
            "nuke": {
                image: "de_nuke.webp",
                pos_x: -3200,
                pos_y: 1768,
                scale: 6
            },
            "inferno": {
                image: "de_inferno.png",
                pos_x: -2000,
                pos_y: 3000,
                scale: 4
            }
        };

        const matchSelector = d3.select("#match-selector");

        function gameToImageCoords(gameX, gameY, mapConfig, imageWidth, imageHeight) {
            const worldX = gameX - mapConfig.pos_x;
            const worldY = mapConfig.pos_y - gameY;
            const pixelX = (worldX / mapConfig.scale) * (imageWidth / 1024);
            const pixelY = (worldY / mapConfig.scale) * (imageHeight / 1024);
            return {
                x: Math.max(0, Math.min(imageWidth, pixelX)),
                y: Math.max(0, Math.min(imageHeight, pixelY))
            };
        }

        function loadMatch(file) {
            d3.select("#heatmap").selectAll("*").remove();
            d3.select("#linechart").selectAll("*").remove();
            d3.select("#piechart").selectAll("*").remove();
            d3.select("#barchart").selectAll("*").remove();
            d3.select("#error-message").text("");
            d3.select("#pie-error").text("");

            fetch(file)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const matchData = data;
                    const mapNameFromFileName = file.replace(/falcons-vs-gamerlegion-m\d+-|.json/g, '').replace(/de_/, '');
                    const currentMapConfig = MAP_CONFIGS[mapNameFromFileName];

                    if (!currentMapConfig) {
                        d3.select("#error-message").text(`Error: Map configuration not found for ${mapNameFromFileName}. Please add it to MAP_CONFIGS.`);
                        return;
                    }

                    const teams = [
                        { name: matchData.teamA?.name || "Team A", color: "#003366" },
                        { name: matchData.teamB?.name || "Team B", color: "#FD7702" }
                    ];

                    const heatmapWidth = 500;
                    const heatmapHeight = 500;

                    const heatmapSvg = d3.select("#heatmap").append("svg")
                        .attr("width", heatmapWidth)
                        .attr("height", heatmapHeight);

                    heatmapSvg.append("image")
                        .attr("xlink:href", currentMapConfig.image)
                        .attr("width", heatmapWidth)
                        .attr("height", heatmapHeight)
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("opacity", 0)
                        .transition()
                        .duration(1000)
                        .attr("opacity", 0.9);

                    const killsData = matchData.kills || [];

                    const imageKills = killsData.map(kill => 
                        gameToImageCoords(kill.victimX, kill.victimY, currentMapConfig, heatmapWidth, heatmapHeight)
                    );
                    console.log("Image Kills:", imageKills);

                    const cellSize = Math.max(5, Math.min(20, 500 / Math.sqrt(killsData.length) || 10));
                    const numCols = Math.floor(heatmapWidth / cellSize);
                    const numRows = Math.floor(heatmapHeight / cellSize);

                    const grid = Array(numRows).fill(0).map(() => Array(numCols).fill(0));

                    imageKills.forEach(p => {
                        const col = Math.floor(p.x / cellSize);
                        const row = Math.floor(p.y / cellSize);
                        if (row >= 0 && row < numRows && col >= 0 && col < numCols) {
                            grid[row][col]++;
                        }
                    });

                    let maxCount = 0;
                    const heatmapCells = [];
                    for (let r = 0; r < numRows; r++) {
                        for (let c = 0; c < numCols; c++) {
                            const count = grid[r][c];
                            if (count > maxCount) maxCount = count;
                            if (count > 0) {
                                heatmapCells.push({
                                    x: c * cellSize,
                                    y: r * cellSize,
                                    width: cellSize,
                                    height: cellSize,
                                    count: count
                                });
                            }
                        }
                    }

                    const colorScale = d3.scale.linear()
                        .domain([0, maxCount])
                        .range(["#fee5d9", "#a50f15"]);

                    heatmapSvg.selectAll(".heatmap-cell")
                        .data(heatmapCells)
                        .enter().append("rect")
                        .attr("class", "heatmap-cell")
                        .attr("x", d => d.x)
                        .attr("y", d => d.y)
                        .attr("width", d => d.width)
                        .attr("height", d => d.height)
                        .attr("fill", d => colorScale(d.count))
                        .attr("opacity", 0)
                        .transition()
                        .duration(500)
                        .attr("opacity", 0.7);

                    const rounds = matchData.rounds || [];
                    if (rounds.length === 0) {
                        d3.select("#linechart").append("text")
                            .attr("x", 10)
                            .attr("y", 20)
                            .attr("fill", "red")
                            .text("No rounds data available for line chart.");
                        return;
                    }

                    const lineData = rounds.map((round, index) => ({
                        x: index + 1,
                        teamA: round.teamAStartMoney || 0,
                        teamB: round.teamBStartMoney || 0,
                        winner: round.winnerTeamName || "No winner"
                    }));

                    const svgWidth = 600;
                    const svgHeight = 400;
                    const margin = {top: 20, right: 20, bottom: 50, left: 50};
                    const chartWidth = svgWidth - margin.left - margin.right;
                    const chartHeight = svgHeight - margin.top - margin.bottom;

                    const lineSvg = d3.select("#linechart").append("svg")
                        .attr("width", svgWidth)
                        .attr("height", svgHeight);

                    const chartGroup = lineSvg.append("g")
                        .attr("transform", `translate(${margin.left},${margin.top})`);

                    const xScale = d3.scale.linear()
                        .domain([1, lineData.length])
                        .range([0, chartWidth]);
                    const xAxis = d3.svg.axis()
                        .scale(xScale)
                        .orient("bottom");
                    const xAxisGroup = chartGroup.append("g")
                        .attr("class", "axis")
                        .attr("transform", `translate(0,${chartHeight})`)
                        .call(xAxis);
                    xAxisGroup.selectAll("text")
                        .style("text-anchor", "end")
                        .attr("dx", "-.8em")
                        .attr("dy", ".15em")
                        .attr("transform", "rotate(-45)");
                    xAxisGroup
                        .attr("opacity", 0)
                        .transition()
                        .duration(1000)
                        .attr("opacity", 1);

                    const maxMoney = d3.max(lineData, d => Math.max(d.teamA, d.teamB)) / 1000 || 50;
                    const yScale = d3.scale.linear()
                        .domain([0, Math.ceil(maxMoney / 10) * 10])
                        .range([chartHeight, 0]);
                    const yAxis = d3.svg.axis()
                        .scale(yScale)
                        .orient("left")
                        .tickValues([0, 10, 20, 30, 40, 50])
                        .tickFormat(d => d === 0 ? "0" : `${d}k`);
                    chartGroup.append("g")
                        .attr("class", "axis")
                        .call(yAxis)
                        .attr("opacity", 0)
                        .transition()
                        .duration(1000)
                        .attr("opacity", 1);

                    const xTicks = xScale.ticks ? xScale.ticks(lineData.length) : d3.range(1, lineData.length + 1);
                    const yTicks = yScale.ticks ? yScale.ticks(5) : [0, 10, 20, 30, 40, 50];

                    yTicks.forEach(yVal => {
                        chartGroup.append("line")
                            .attr("x1", 0)
                            .attr("y1", yScale(yVal))
                            .attr("x2", chartWidth)
                            .attr("y2", yScale(yVal))
                            .attr("stroke", "#ccc")
                            .attr("stroke-width", 1)
                            .attr("opacity", 0)
                            .transition()
                            .duration(1000)
                            .attr("opacity", 0.85);
                    });

                    xTicks.forEach(xVal => {
                        chartGroup.append("line")
                            .attr("x1", xScale(xVal))
                            .attr("y1", 0)
                            .attr("x2", xScale(xVal))
                            .attr("y2", chartHeight)
                            .attr("stroke", "#ccc")
                            .attr("stroke-width", 1)
                            .attr("opacity", 0)
                            .transition()
                            .duration(1000)
                            .attr("opacity", 0.85);
                    });

                    const lineA = d3.svg.line()
                        .x(d => xScale(d.x))
                        .y(d => yScale(d.teamA / 1000));
                    const pathA = chartGroup.append("path")
                        .datum(lineData)
                        .attr("fill", "none")
                        .attr("stroke", teams[0].color)
                        .attr("stroke-width", 1.2)
                        .attr("d", lineA(lineData))
                        .attr("stroke-dasharray", function() { return this.getTotalLength(); })
                        .attr("stroke-dashoffset", function() { return this.getTotalLength(); })
                        .transition()
                        .duration(2000)
                        .attr("stroke-dashoffset", 0);

                    const lineB = d3.svg.line()
                        .x(d => xScale(d.x))
                        .y(d => yScale(d.teamB / 1000));
                    const pathB = chartGroup.append("path")
                        .datum(lineData)
                        .attr("fill", "none")
                        .attr("stroke", teams[1].color)
                        .attr("stroke-width", 1.2)
                        .attr("d", lineB(lineData))
                        .attr("stroke-dasharray", function() { return this.getTotalLength(); })
                        .attr("stroke-dashoffset", function() { return this.getTotalLength(); })
                        .transition()
                        .duration(2000)
                        .attr("stroke-dashoffset", 0);

                    chartGroup.selectAll(".data-point-teamA")
                        .data(lineData)
                        .enter().append("circle")
                        .attr("class", "data-point data-point-teamA")
                        .attr("cx", d => xScale(d.x))
                        .attr("cy", d => yScale(d.teamA / 1000))
                        .attr("r", 3)
                        .attr("opacity", 0)
                        .transition()
                        .duration(1000)
                        .attr("opacity", 0.7);

                    chartGroup.selectAll(".data-point-teamB")
                        .data(lineData)
                        .enter().append("circle")
                        .attr("class", "data-point data-point-teamB")
                        .attr("cx", d => xScale(d.x))
                        .attr("cy", d => yScale(d.teamB / 1000))
                        .attr("r", 3)
                        .attr("opacity", 0)
                        .transition()
                        .duration(1000)
                        .attr("opacity", 0.7);

                    chartGroup.selectAll(".data-point-teamA")
                        .on("mouseover", function(d) {
                            const rect = this.getBoundingClientRect();
                            const tooltip = d3.select("#tooltip");
                            const didWin = (d.winner === teams[0].name || d.winner === "Team A") ? "Yes" : "No";
                            tooltip
                                .style("left", (rect.left + rect.width / 2) + "px")
                                .style("top", (rect.top - 40) + "px")
                                .html(`Round: ${d.x}<br>${teams[0].name} Money: $${d.teamA}<br>Won Round: ${didWin}`)
                                .style("display", "block");
                        })
                        .on("mouseout", function() {
                            d3.select("#tooltip").style("display", "none");
                        });

                    chartGroup.selectAll(".data-point-teamB")
                        .on("mouseover", function(d) {
                            const rect = this.getBoundingClientRect();
                            const tooltip = d3.select("#tooltip");
                            const didWin = (d.winner === teams[1].name || d.winner === "Team B") ? "Yes" : "No";
                            tooltip
                                .style("left", (rect.left + rect.width / 2) + "px")
                                .style("top", (rect.top - 40) + "px")
                                .html(`Round: ${d.x}<br>${teams[1].name} Money: $${d.teamB}<br>Won Round: ${didWin}`)
                                .style("display", "block");
                        })
                        .on("mouseout", function() {
                            d3.select("#tooltip").style("display", "none");
                        });

                    chartGroup.append("text")
                        .attr("transform", `translate(${chartWidth/2},${chartHeight + margin.bottom - 10})`)
                        .style("text-anchor", "middle")
                        .text("Round")
                        .attr("opacity", 0)
                        .transition()
                        .duration(1000)
                        .attr("opacity", 1);
                    chartGroup.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("y", -5 - margin.left)
                        .attr("x", 0 - (chartHeight / 2))
                        .attr("dy", "1em")
                        .style("text-anchor", "middle")
                        .text("Money ($)")
                        .attr("opacity", 0)
                        .transition()
                        .duration(1000)
                        .attr("opacity", 1);

                    const lineLegend = chartGroup.append("g")
                        .attr("class", "legend")
                        .attr("transform", `translate(${chartWidth - 100}, 10)`);
                    teams.forEach((team, i) => {
                        const legendRow = lineLegend.append("g")
                            .attr("transform", `translate(0, ${i * 20})`);
                        legendRow.append("rect")
                            .attr("x", 0)
                            .attr("y", 0)
                            .attr("width", 15)
                            .attr("height", 15)
                            .attr("fill", team.color);
                        legendRow.append("text")
                            .attr("x", 20)
                            .attr("y", 12)
                            .text(team.name);
                        legendRow.attr("opacity", 0)
                            .transition()
                            .duration(1000)
                            .attr("opacity", 1);
                    });

                    const pieSvg = d3.select("#piechart").append("svg")
                        .attr("width", 500)
                        .attr("height", 300)
                        .append("g")
                        .attr("transform", "translate(150,150)");

                    console.log("Round winners:", rounds.map(round => round.winnerTeamName));

                    const wins = rounds.reduce((acc, round) => {
                        const winner = round.winnerTeamName ? round.winnerTeamName.trim() : null;
                        if (!winner) return acc;
                        if (winner === "Team A" || winner === teams[0].name) {
                            acc.teamA++;
                        } else if (winner === "Team B" || winner === teams[1].name) {
                            acc.teamB++;
                        } else {
                            console.warn(`Unrecognized winner team name: ${winner}`);
                        }
                        return acc;
                    }, { teamA: 0, teamB: 0 });

                    console.log("Calculated Wins:", wins);

                    if (wins.teamA === 0 && wins.teamB === 0 && rounds.length > 0) {
                        d3.select("#pie-error").text("No definitive wins recorded for either team.");
                    }

                    const pieData = [
                        { label: teams[0].name, value: wins.teamA },
                        { label: teams[1].name, value: wins.teamB }
                    ];

                    const pie = d3.layout.pie()
                        .value(d => d.value)
                        .sort(null);

                    const arc = d3.svg.arc()
                        .innerRadius(0)
                        .outerRadius(100);

                    const arcs = pieSvg.selectAll(".arc")
                        .data(pie(pieData))
                        .enter()
                        .append("g")
                        .attr("class", "arc");

                    arcs.append("path")
                        .attr("fill", (d, i) => teams[i].color)
                        .attr("d", arc)
                        .each(function(d) { this._current = { startAngle: d.startAngle, endAngle: d.startAngle }; })
                        .transition()
                        .duration(1000)
                        .attrTween("d", function(d) {
                            const interpolate = d3.interpolate(this._current, d);
                            this._current = interpolate(0);
                            return t => arc(interpolate(t));
                        });

                    arcs.append("text")
                        .attr("transform", d => `translate(${arc.centroid(d)})`)
                        .attr("dy", ".35em")
                        .style("text-anchor", "middle")
                        .style("fill", "white")
                        .text(d => d.data.value > 0 ? d.data.value : "")
                        .attr("opacity", 0)
                        .transition()
                        .duration(500)
                        .attr("opacity", 1);

                    const pieLegend = pieSvg.append("g")
                        .attr("class", "legend")
                        .attr("transform", `translate(150, -40)`);
                    pieData.forEach((data, i) => {
                        const legendRow = pieLegend.append("g")
                            .attr("transform", `translate(0, ${i * 20})`);
                        legendRow.append("rect")
                            .attr("x", 0)
                            .attr("y", 0)
                            .attr("width", 15)
                            .attr("height", 15)
                            .attr("fill", teams[i].color);
                        legendRow.append("text")
                            .attr("x", 20)
                            .attr("y", 12)
                            .text(data.label);
                        legendRow.attr("opacity", 0)
                            .transition()
                            .duration(1000)
                            .attr("opacity", 1);
                    });

                    const barSvg = d3.select("#barchart").append("svg")
                        .attr("width", 600)
                        .attr("height", 400);

                    const barMargin = { top: 25, right: 20, bottom: 50, left: 100 };
                    const barWidth = 600 - barMargin.left - barMargin.right;
                    const barHeight = 400 - barMargin.top - barMargin.bottom;

                    const barGroup = barSvg.append("g")
                        .attr("transform", `translate(${barMargin.left},${barMargin.top})`);

                    const weaponStats = {};
                    matchData.kills.forEach(kill => {
                        const weapon = kill.weaponName;
                        if (!weapon) return;
                        if (!weaponStats[weapon]) {
                            weaponStats[weapon] = { weapon, count: 0, headshots: 0 };
                        }
                        weaponStats[weapon].count += 1;
                        if (kill.isHeadshot === true) {
                            weaponStats[weapon].headshots += 1;
                        }
                    });

                    const bodyshotsChecked = document.getElementById("bodyshots").checked;
                    const headshotsChecked = document.getElementById("headshots").checked;
                    let weaponData;

                    if (bodyshotsChecked && !headshotsChecked) {
                        weaponData = Object.values(weaponStats)
                            .map(stat => ({
                                weapon: stat.weapon,
                                count: stat.count - stat.headshots,
                                headshots: 0
                            }))
                            .filter(stat => stat.count > 0)
                            .sort((a, b) => b.count - a.count)
                            .slice(0, 5);
                    } else if (headshotsChecked && !bodyshotsChecked) {
                        weaponData = Object.values(weaponStats)
                            .map(stat => ({
                                weapon: stat.weapon,
                                count: stat.headshots,
                                headshots: stat.headshots
                            }))
                            .filter(stat => stat.count > 0)
                            .sort((a, b) => b.count - a.count)
                            .slice(0, 5);
                    } else {
                        weaponData = Object.values(weaponStats)
                            .sort((a, b) => b.count - a.count)
                            .slice(0, 5);
                    }

                    if (weaponData.length === 0) {
                        barGroup.append("text")
                            .attr("x", barWidth / 2)
                            .attr("y", barHeight / 2)
                            .attr("text-anchor", "middle")
                            .attr("fill", "red")
                            .text("No weapon kill data available.");
                        return;
                    }

                    const barXScale = d3.scale.ordinal()
                        .domain(weaponData.map(d => d.weapon))
                        .rangeRoundBands([0, barWidth], 0.1);
                    const barYScale = d3.scale.linear()
                        .domain([0, d3.max(weaponData, d => d.count)])
                        .range([barHeight, 0]);

                    const barXAxis = d3.svg.axis()
                        .scale(barXScale)
                        .orient("bottom")
                        .tickFormat(d => d);
                    barGroup.append("g")
                        .attr("class", "axis")
                        .attr("transform", `translate(0,${barHeight})`)
                        .call(barXAxis)
                        .attr("opacity", 0)
                        .transition()
                        .duration(1000)
                        .attr("opacity", 1)
                        .selectAll("text")
                        .style("text-anchor", "end")
                        .attr("dx", "-.8em")
                        .attr("dy", ".15em")
                        .attr("transform", "rotate(-45)");

                    const barYAxis = d3.svg.axis()
                        .scale(barYScale)
                        .orient("left")
                        .tickFormat(d => d);
                    barGroup.append("g")
                        .attr("class", "axis")
                        .call(barYAxis)
                        .attr("opacity", 0)
                        .transition()
                        .duration(1000)
                        .attr("opacity", 1);

                    const bars = barGroup.selectAll(".bar")
                        .data(weaponData)
                        .enter().append("rect")
                        .attr("class", "bar")
                        .attr("x", d => barXScale(d.weapon))
                        .attr("y", barHeight)
                        .attr("width", barXScale.rangeBand())
                        .attr("height", 0)
                        .attr("opacity", 0);

                    bars.transition()
                        .duration(1000)
                        .attr("y", d => barYScale(d.count))
                        .attr("height", d => barHeight - barYScale(d.count))
                        .attr("opacity", 1);

                    bars.on("mouseover", function(d) {
                        const rect = this.getBoundingClientRect();
                        const tooltip = d3.select("#tooltip");
                        tooltip
                            .style("left", (rect.left + rect.width / 2) + "px")
                            .style("top", (rect.top - 40) + "px")
                            .html(`Kills: ${d.count}<br>Headshots: ${d.headshots}`)
                            .style("display", "block");
                    })
                    .on("mouseout", function() {
                        d3.select("#tooltip").style("display", "none");
                    });
                })
                .catch(error => {
                    console.error('Error loading or processing JSON:', error);
                    d3.select("#error-message").text(`Error loading match data: ${error.message}`);
                });
        }

        Promise.all(matchFiles.map(file => fetch(file).then(res => res.json())))
            .then(datas => {
                const options = matchFiles.map((file, i) => {
                    const data = datas[i];
                    const mapName = file.replace(/falcons-vs-gamerlegion-m\d+-|.json/g, '').replace(/_/g, ' ');
                    const formattedMapName = mapName.charAt(0).toUpperCase() + mapName.slice(1);
                    return {
                        file,
                        label: `${data.teamA?.name || "Team A"} vs ${data.teamB?.name || "Team B"} - ${formattedMapName}`
                    };
                });

                matchSelector.selectAll("option")
                    .data(options)
                    .enter()
                    .append("option")
                    .attr("value", d => d.file)
                    .text(d => d.label);

                if (matchFiles.length > 0) {
                    loadMatch(matchFiles[0]);
                } else {
                    d3.select("#error-message").text("No match files defined.");
                }

                matchSelector.on("change", function() {
                    const selectedFile = d3.select(this).property("value");
                    loadMatch(selectedFile);
                });

                document.getElementById("bodyshots").addEventListener("change", () => loadMatch(matchSelector.property("value")));
                document.getElementById("headshots").addEventListener("change", () => loadMatch(matchSelector.property("value")));
            })
            .catch(error => {
                console.error('Error loading match files for dropdown:', error);
                matchSelector.append("option").text("Error loading matches");
            });
    </script>
</body>
</html>